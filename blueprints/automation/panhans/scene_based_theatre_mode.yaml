blueprint:
  name: ðŸŽ¬ Scene Based Theatre Mode
  description: "

    **Features**
  

    ðŸŽ¬ activates scenes depending on media player states and content types
    
    ðŸ” automatic caching and restoring of the states of the entities of the Playing Scene

    ðŸŒ‡ transition time for switching scenes


    **Help & FAQ**: [Scene based theatre mode](https://community.home-assistant.io/t/scene-based-theatre-mode)


    **Version**: 2.1
    

    If you like my work and support feel free to support me.

    [![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/Q5Q3QEH52)
    "

  source_url: "https://github.com/panhans/HomeAssistant/blob/main/blueprints/automation/panhans/scene_based_theatre_mode.yaml"
  domain: automation
  input:
          
    media_player:
      name: ðŸ“» Media Player
      description: >
        `media player`
      
      
        Media Player, which commands the automation.
      selector:
        entity:
          filter:
            domain: media_player
    
    content_type:
      name: ðŸ“º Content Type
      description: >
        `content_type`


        Type of content streamed to the media player.
        Can be used if you want to differentiate scenes
        based on the content streamed to the media player.
      default: "all"
      selector:
        select:
          mode: dropdown
          options:
            - "all"
            - "music"
            - "video"

    scene_playing:
      name: â–¶ï¸ Playing
      description: >
        `scene`
      
      
        Scene to be activated when the player is playing.
      selector:
        entity:
          filter:
            domain: scene

    scene_paused:
      name: â¸ï¸ Paused
      description: >
        `scene`
      
      
        Scene to be activated when the player is paused.
      selector:
        entity:
          filter:
            domain: scene

    reaction_time:
      name: â±ï¸ Reaction time
      description: >
        `reaction` `for time`


        The time period in which the media player must remain in a state.
      default: 2
      selector:
        number:
          unit_of_measurement: s
          min: 1
          max: 10
          step: 1
          mode: slider

    transition:
      name: â†• Transition
      description: >
        `transition`
      
      
        Transition time during the scene change.
      default: 1
      selector:
        number:
          min: 1
          max: 10
          step: 1
          mode: slider

    input_custom_condition:
      name: â˜‘ï¸ Custom Condition
      description: >
        `optional`


        Block (False) / Allow (True) theatre mode.
      default: "{{ 1 == 1 }}"
      selector:
        condition:

trigger:

  - trigger: state
    entity_id: !input media_player
    for:
      seconds: !input reaction_time

variables:

  media_player: !input media_player
  content_type: !input content_type

  scene_playing: !input scene_playing
  scene_paused: !input scene_paused
  scene_entities: "{{ state_attr(scene_playing,'entity_id') }}"

  scene_init_state: "{{ 'scene.' + this.entity_id | replace('automation.','') | replace('.','_') + '_tm' }}"

  from_state: "{{ trigger.from_state.state }}"
  from_content_type: "{{ trigger.from_state.attributes.media_content_type | default('from_init', true) }}"
  to_state: "{{ trigger.to_state.state }}"
  to_content_type: "{{ trigger.to_state.attributes.media_content_type | default('to_init', true) }}"

  is_relevant_content: "{{ to_content_type == content_type or to_content_type == 'all' or to_content_type == 'to_init' }}"

  is_start: >
    {{ 
      to_state == 'playing' and
      from_state not in [ "paused"] and
      from_content_type != to_content_type
    }}

  is_end: >
    {{ 
      to_state in ["idle",
                    "off",
                    "stopped",
                    "standby",
                    "unknown",
                    "unavailable"]
    }}

  is_paused: "{{ from_state == 'playing' and to_state == 'paused' }}"
  is_resume: "{{ from_state == 'paused' and to_state == 'playing' }}"

  scene_to_apply: >
    {% if is_start or is_resume %}
      {{ scene_playing }}
    {% elif is_paused %}
      {{ scene_paused }}
    {% elif is_end %}
      {{ scene_init_state }}
    {% endif %}

conditions:
  - condition: template
    value_template: "{{ is_resume or is_paused or is_end or is_start }}"
  - condition: template
    value_template: "{{ is_relevant_content }}"
  - condition: and
    conditions: !input input_custom_condition
    
action:
    - if:
      - condition: template
        value_template: "{{ is_start }}"
      then:
        - action: scene.create
          data:
            scene_id: "{{ scene_init_state.split('.')[1] }}"
            snapshot_entities: "{{ scene_entities }}"
        - delay:
            seconds: 2

    - if:
      - condition: template
        value_template: "{{ states[scene_to_apply] != none }}"
      then:
      - action: scene.turn_on
        data:
          transition: !input transition
        target:
          entity_id: "{{ scene_to_apply }}"

mode: queued
