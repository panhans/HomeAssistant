blueprint:
  name: Advanced Heating Control ~~dev~~
  author: panhans
  homeassistant:
    min_version: "2024.2.0"
  description: "

    

    ðŸ”¥ heating based on


    > ðŸ‘¥ people presence

      ðŸ—“ï¸ multiple schedulers

      ðŸš¶ presence sensor

      â†”ï¸ proximity aka geo fencing


    â„ frost protection

    ðŸ˜¡ adjustable aggressive mode

    ðŸŒ¤ï¸ activation based on weather, temperature or boolean entities

    ðŸŽ›ï¸ granular schedule adjustments

    ðŸªŸ multiple window open detection

    ðŸŽˆ party mode

    ðŸ¤ guest mode

    ðŸ§­ thermostat calibration for the most common devices (Tado, Aqara, Popp / Danfoss / Hive, Tuya)

    âš™ï¸ several tweaks for fixing your thermostat issues

    ðŸŽ¬ custom action

    ðŸ¤« calm & ðŸ’ª reliable



    **Version**: 4.0.3_dev_3

    **Help & FAQ**: [Advanced Heating Control](https://community.home-assistant.io/t/advanced-heating-control)

    **Documentation:** work in progress


    [![ko-fi](https://ko-fi.com/img/githubbutton_sm.svg)](https://ko-fi.com/Q5Q3QEH52)

    "
  source_url: https://github.com/panhans/HomeAssistant/blob/dev_v4/blueprints/automation/panhans/heating_control.yaml
  domain: automation
  input:
    input_trvs:
      name: ðŸ”¥ Thermostats / Climates
      description: >
        `thermostats` `climates` 


        Thermostats to be controlled.
      selector:
        entity:
          filter:
            - domain:
                - climate
          multiple: true

    input_temperature_minimum_static:
      name: ðŸŒ± Static Eco Temperature
      description: >
        `eco temperature`


        The temperature that is set when your heating schedule is not active.
      default: 19
      selector:
        number:
          min: 4.0
          max: 75.0
          step: 0.5
          mode: box
          unit_of_measurement: Â°C / Â°F

    input_temperature_minimum:
      name: ðŸŒ± Eco Temperature
      description: >
        `eco temperature` `optional`


        To control your eco temperature via automations or the UI, you can specify an *input_number* entity here.


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_number
          multiple: false

    # C O M F O R T   &   M O D S
    input_temperature_comfort_static:
      name: ðŸ›‹ï¸ Static Comfort Temperature
      description: >
        `comfort temperature`


        You can set a static comfort temperature here.
      default: 22
      selector:
        number:
          min: 12.0
          max: 86.0
          step: 0.5
          mode: box
          unit_of_measurement: Â°C / Â°F

    input_temperature_comfort:
      name: ðŸ›‹ï¸ Comfort Temperature
      description: >
        `comfort temperature` `optional`


        To control your comfort temperature via automations or the UI, you can specify an *input_number* entity here.


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_number
          multiple: false

    input_time_based_temperature_change_valve_target:
      name: ðŸŽ›ï¸ Heating Schedule Adjustments
      description: >
        `optional`


        Here you can setup some adjustments to your heating schedule. What's possibible until now?
        <br/>

        > ðŸ•” **time**
        
        > Timestamp when the adjustment should kick in. (required)


        > ðŸ“† **days**
        
        > Select days where this setting shall be enabled.
        
        > ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']


        > ðŸ—“ï¸ **scheduler**
        
        > Only enable this entry if this string is part of the name of your active scheduler.


        > ðŸ›‹ï¸ **comfort**
        
        > Adjust comfort temperature


        > ðŸŒ± **eco**
       
        > Adjust eco temperature


        > ðŸ§­ **calibration**
        
        > Toggle calibration 
        
        > on/off


        Example:
        <br/>

        ```yaml

        - time: "08:00"
          comfort: "20"
          calibration: "off"
        - time: "16:00"
          eco: "19"
          calibration: "on"
        - time: "20:00"
          days: ['Sat','Sun']
          scheduler: 'Holidays'
          comfort: "24"
          eco: "17"
        ```

      selector:
        object:
      default: "[]"

    # P E R S O N S
    input_persons:
      name: ðŸ‘¥ People
      description: >
        `people` `optional`


        You can specify people to make your heating plan more dynamic. If you do not use schedulers or presence sensors, heating is activated as soon as someone is at home.<br/>
        With schedulers or presence sensors, these are only active when someone is at home.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - person
          multiple: true

    input_people_entering_home_duration:
      name: ðŸ  Enter Home Duration
      description: >
        `people`


        Duration for which someone must be at home for heating to be activated.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    input_people_leaving_home_duration:
      name: ðŸ’¨ Leaving Home Duration
      description: >
        `people`


        Duration for which someone must be out of the house for heating to be deactivated.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    # P R O X I M I T Y
    input_proximity:
      name: â†”ï¸ Proximity
      description: >
        `proximity` `optional`


        You can preheat your rooms with help of home assistant's [proximity integration](https://www.home-assistant.io/integrations/proximity/).<br/>
        Just select your proxmity zone and take your adjustments to distance and duration.<br/>
        If you're in range of your distance and towards to your home heating kicks in. If you don't specify any scheduler or presence detector heating also is enabled if you arrived.<br/>

        **Note**: If *on way home* is detected this gets handled like presence is on or somebody is home. So this has to match with the states of your schedulers if you use them.
      default: ""
      selector:
        device:
          filter:
            integration: proximity
          multiple: false

    input_proximity_duration:
      name: â° Proximity Duration
      description: >
        `proximity`


        Duration for which someone must be on way home before heating occurs.
      default:
        hours: 0
        minutes: 2
        seconds: 0
      selector:
        duration:

    input_proximity_distance:
      name: â†”ï¸ Proximity Distance
      description: >
        `proximity`


        The distance when proximity sensor gets impact for this automation. Hint: Unit depends on the setup of your integration.
      default: 500
      selector:
        number:
          min: 0
          max: 999999999
          step: 1
          mode: box

    # S C H E D U L E R
    input_schedulers:
      name: â²ï¸ Scheduler
      description: >
        `scheduler` `optional`


        A scheduler specifies when heating to comfort temperature should take place. You can create it in the helper section of Home Assistant.<br/>
        If you have also specified people, someone must also be at home for heating.<br/>
        You can create as many schedulers as you like. Make sure the names are clear.


        Create your scheduler [here](https://my.home-assistant.io/redirect/helpers/).
      default: []
      selector:
        entity:
          filter:
            - domain:
                - schedule
          multiple: true

    input_scheduler_selector:
      name: â˜ðŸ» Scheduler Selector
      description: >
        `scheduler` `optional`


        Define an entity to choose from your schedulers. If you use one scheduler only you can ignore this. If you use more than one scheduler you have multiple possibilities to setup your selection: <br/>

        * toggle (*input_boolean*) or *binary_sensor*: If *off* the first defined scheduler is active. If *on* second scheduler is active. More than 2 schedulers cannot be selected with binary inputs.

        * text (*input_text*), drop down (*input_select*) or sensor:
          * The value has to match the friendly name of the selected scheduler at least partially. Example: If you provide three schedulers called *work*, *holiday/sick*, *guest* you can select the holiday scheduler while setting the selection entity to *sick*, *holiday* or *holiday/sick*. This option is case insensitive.
          * You also can go with numbers: if you want to choose the first scheduler the selector entity must return the number *1*. For the 2nd number *2* and so on.


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - input_text
                - input_number
                - input_select
          multiple: false

    # P R E S E N C E
    input_presence_sensor:
      name: ðŸš¶ Presence Sensor
      description: >
        `presence detection` `optional`


        If you specify a presence sensor, heating will take place if it detects presence.<br/>
        If you have specified people, at least one must also be at home.
      default:
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
                - input_boolean
          multiple: false

    input_scheduler_presence:
      name: â²ï¸ Presence Sensor Scheduler
      description: >
        `presence detection` `optional`


        The presence scheduler specifies exactly when the presence sensor should be used during the day.
      default:
      selector:
        entity:
          filter:
            - domain:
                - schedule
          multiple: false

    input_presence_reaction_on_time:
      name: â³ Presence Reaction On Time
      description: >
        `presence detection`


        Specify the duration for which the presence sensor must detect any presence so that the comfort temperature is set.
      default:
        hours: 0
        minutes: 5
        seconds: 0
      selector:
        duration:

    input_presence_reaction_off_time:
      name: âŒ› Presence Reaction Off Time
      description: >
        `presence detection`


        Specify the duration for which the presence sensor must not detect any presence so that the minimum temperature is set.
      default:
        hours: 0
        minutes: 5
        seconds: 0
      selector:
        duration:

    # M O D E S
    input_mode_party:
      name: ðŸŽˆ Party mode
      description: >
        `optional`


        If on, all settings are ignored and heating takes place.


        Create your timer [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - timer
          multiple: false

    input_mode_guest:
      name: ðŸ¤ Guest mode
      description: >
        `optional`



        If an entity is specified here, it is treated like a person. It's usefull when you're leaving your guests alone in your home and you are not using presence detection.
          
          * entity defined -> person defined
          * enitity is *on* -> simulates person is home
          * enitity is *off* -> simulates person is away


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
                - timer
          multiple: false

    # W I N D O W   O P E N   D E T E C T I O N
    input_windows:
      name: ðŸªŸ Windows & Doors
      description: >
        `airing` `optional`


        If open during airing your thermostates will be set to *off* at least to their minimum temperature if they don't support hvac mode *OFF*.
      default: []
      selector:
        entity:
          filter:
            - domain:
                - binary_sensor
          multiple: true

    input_windows_reaction_time_open:
      name: â³ Window & Door Reaction Time Open
      description: >
        `airing`


        Duration for which a window or door must be open for the thermostats to close.
      default:
        hours: 0
        minutes: 0
        seconds: 30
      selector:
        duration:

    input_windows_reaction_time_close:
      name: âŒ› Window & Door Reaction Time Close
      description: >
        `airing`  


        Duration for which a window or door must be closed for the thermostats to open.
      default:
        hours: 0
        minutes: 0
        seconds: 30
      selector:
        duration:

    # F R O S T   P R O T E C T I O N
    input_frost_protection_temp:
      name: â„ï¸ Frost Protection Temperature
      description: >
        `frost protection`


        You can set the frost protection temperature here.
      default: 5
      selector:
        number:
          min: 5.0
          max: 62.0
          step: 0.5
          mode: box
          unit_of_measurement: Â°C / Â°F

    input_frost_protection_duration:
      name: â„ï¸ Frost Protection Fallback Duration
      description: >
        `frost protection`


        If the defined persons are not at home for a longer period of time or the presence sensor has no longer detected any presence, the frost protection temperature can be lowered after a this duration.
        Note: If set to zero frost protection temperature never will be set.
      default:
        days: 0
        hours: 0
        minutes: 0
        seconds: 0
      selector:
        duration:
          enable_day: true

    # C A L I B R A T I O N
    input_temperature_sensor:
      name: ðŸŒ¡ï¸ Calibration Temperature Sensor
      description: >
        `calibration` `optional`


        Temperature calibration for your thermostats. The following is supported:

          * Tado, Aqara, Popp, Danfoss, Hive, Tuya
          * generic calibration

        Note: This is an additional sensor inside your room usually next to your favourite spot. Thermostats or its integration (e.g. Z2M or ZHA) except Tado should provide a seperate clibration enitity.
      default:
      selector:
        entity:
          filter:
            - domain:
                - sensor
              device_class:
                - temperature
          multiple: false

    input_calibration_timeout:
      name: â³ Calibration Timeout
      description: >
        `calibration`


        Define a timeout if you want to decrease the amount of calibration calls if temperature changes too much.
        At least the temperature of the external sensor or thermostat must stay for that duration before calibration gets triggered.

        **HINT:** A minimum timeout of 2s is recommended.
      default:
        hours: 0
        minutes: 1
        seconds: 0
      selector:
        duration:

    input_calibration_delta:
      name: â†”ï¸ Calibration Delta
      description: >
        `calibration`


        If the difference between the thermostat temperature and the external sensor temperature is greater or less than the calibration delta the thermostat calibration will be triggered.<br/>
        The lower the delta the often calibration gets triggered.
      default: 0.5
      selector:
        number:
          min: 0
          max: 5
          step: 0.1
          mode: slider
          unit_of_measurement: Â°C / Â°F

    input_calibration_options:
      name: âš™ï¸ Calibration Tweaks
      description: "
        `calibration`

        > ### ðŸ§­ Generic Calibration

        > Adds the difference between room and thermostat temperature to the target temperature.

        > ### ðŸŒ• Fully Rounded Values

        > Enable this if you thermostat calibration entity accept floating values but only save them as integers.

        "

      default: []
      selector:
        select:
          options:
            - label: "ðŸ§­ Generic Calibration"
              value: generic_calibration
            - label: "ðŸŒ• Fully Rounded Values"
              value: rounded_values
          multiple: true
          custom_value: false
          mode: list

    # W I N T E R  M O D E
    input_mode_winter:
      name: â›„ Winter Mode / Automation Toggle
      description: >
        `activation` `optional`


        If *on* the automation is active. If *off* your valves will set to *off* and the automation is going to sleep.
        You can set this up with:

          * input boolean
          * binary sensor


        Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
                - binary_sensor
          multiple: false

    input_mode_outside_temperature:
      name: ðŸŒ¤ï¸ Outside Temperature Sensor
      description: >
        `activation` `optional`


        You can control the switching on and off of your thermostats via the outside temperature. 
        To do this, select a temperature sensor or a weather entity and adjust the threshold below.

          * weather entity
          * temperature entity

      default:
      selector:
        entity:
          filter:
            - domain:
                - weather
            - domain:
                - sensor
              device_class: temperature
          multiple: false

    input_mode_outside_temperature_threshold:
      name: ðŸŽšï¸ Outside Temperature Threshold
      description: >
        `activation`


        If you'd select a temperature sensor or a weather entity for controlling heating you can adjust the temperature threshold here.
        If the outside temperature falls below the threshold value, heating is activated.
      default: 15
      selector:
        number:
          min: 5
          max: 68
          step: 1
          mode: box
          unit_of_measurement: Â°C / Â°F

    # M O D I F I E R S
    input_aggressive_mode_range:
      name: ðŸ˜¡ Agressive Mode - Range
      description: >
        `aggressive mode` `tweak`


        Activate this option if your valves react slowly or only start to react at a large temperature difference between actual and set temperature.
        Define a range when your real target temperature shall be set. E.g. you target temperature is 20Â°C and your room temperature is 19.5Â°C.
        If your range is set to 0.5Â°C the real target temperature (20Â°C) will be set when room temperature is between 19.5Â°C and 20.5Â°C.
        If the room temperature is above or lower that range it gets some offset in order to force your thermostat to react. (see Aggressive Mode - Offset)
      default: 0
      selector:
        number:
          min: 0
          max: 5
          step: 0.1
          mode: slider
          unit_of_measurement: Â°C / Â°F

    input_aggressive_mode_offset:
      name: ðŸ˜¡ Agressive Mode - Offset
      description: >
        `aggressive mode` `tweak`


        Here you can define the offset that will be added to your target temperature if the room temperature is not in range of your target temperature.
        If your room temperature is not in the defined range, e.g. 19.5Â°C - 20.5Â°C this offset will be added to your target temperature.
      default: 0
      selector:
        number:
          min: 0
          max: 5
          step: 0.5
          mode: slider
          unit_of_measurement: Â°C / Â°F

    # TWEAKS
    input_service_call_delay:
      name: âš™ï¸ Service Call Delay
      description: >
        `tweak`


        Some thermostats have problems with setting mode and temperature. You can try to increase the
        delay between the service calls. This could fix your problems.
      default:
        hours: 0
        minutes: 0
        seconds: 2
      selector:
        duration:

    input_tweaks:
      name: âš™ï¸ Tweaks
      description: "
        `tweak`


        > ### â†©ï¸ Reset Temperature

        > Reset your temperature after party ends or temperature go from comfort to eco

        > ### ðŸ›‘ Turn *OFF* Instead Of Eco Temperature

        > Turn off your thermostats instead of lower the temperature to eco temperature

        > ### ðŸŒ± Eco Temperature Instead Of *OFF*

        > Lower the temperature instead of turning them *OFF*, e.g. during airing

        > ### ðŸ…°ï¸ *AUTO* means *HEAT*

        > Enable this if *AUTO* is the heat mode of your thermostat

        > ### ðŸ‡« Fahrenheit

        > Enable this if your unit of measurement is Fahrenheit (untested)

        "

      default: []
      selector:
        select:
          options:
            - label: "â†©ï¸ Reset Temperature"
              value: reset_temperature
            - label: "ðŸ›‘ Off Instead Of Eco"
              value: off_instead_min
            - label: "ðŸŒ± Eco Instead Of Off"
              value: not_off_but_min
            - label: "ðŸ…°ï¸ Auto Means Heat"
              value: auto_means_heat
            - label: "ðŸ‡« Fahrenheit"
              value: fahrenheit
          multiple: true
          custom_value: false
          mode: list

    # E X P E R I M E N T A L
    input_tweaks_experimental:
      name: ðŸ§ª Experimental Tweaks
      description: "
        `tweak`


        > ### ðŸŒ¡ï¸ Physical Temperature Change

        > Adjust the temperature via your thermostats.

        > ### ðŸŽˆ Start Party Timer On Physical Change

        > Start your party timer when you change the temperature via your thermostats.


        **HINT**: This features may won't work properly since there is a [bug](https://github.com/home-assistant/core/issues/99914) in home assistant.

        "

      default: []
      selector:
        select:
          options:
            - label: "ðŸŒ¡ï¸ Physical Temperature Change"
              value: physical_temperature_change
            - label: "ðŸŽˆ Start Party Timer On Physical Change"
              value: physical_party_timer
          multiple: true
          custom_value: false
          mode: list

    input_force_max_temperature:
      name: ðŸ¥µ Force Max Temperature
      description: >
        `optional`


        Set the maximum temperature of all thermostats regardless of any other settings.


        **HINT:** Implemented by developer for maintenance reasons. Create your helper [here](https://my.home-assistant.io/redirect/helpers/).
      default:
      selector:
        entity:
          filter:
            - domain:
                - input_boolean
          multiple: false

    # C U S T O M   A C T I O N
    input_custom_action:
      name: ðŸŽ¬ Custom Action
      description: >
        `optional`


        This custom action gets executed with every temperature / mode change except calibration. If you want to control other devices just check states before doing a service call.
        Use the variable *is_heating* in your conditions. *True* means heating is active.
      default:
      selector:
        action:

    input_log_level:
      name: âœï¸ Log Level
      description: ""
      default: debug
      selector:
        select:
          mode: dropdown
          options:
            - info
            - warning
            - error
            - debug

##################################################
############### T R I G G E R ####################
##################################################

trigger_variables:
  # M O D E S
  input_mode_winter: !input input_mode_winter
  input_mode_party: !input input_mode_party
  input_mode_guest: !input input_mode_guest
  input_force_max_temperature: !input input_force_max_temperature

  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_minimum: !input input_temperature_minimum
  input_time_based_temperature_change_valve_target: !input input_time_based_temperature_change_valve_target

  # S C H E D U L E R
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector
  input_scheduler_presence: !input input_scheduler_presence

  # A D D I T I O N A L   S E T T I N G S
  input_trvs: !input input_trvs
  input_windows: !input input_windows
  input_temperature_sensor: !input input_temperature_sensor
  input_persons: !input input_persons
  input_presence_sensor: !input input_presence_sensor
  input_calibration_timeout: !input input_calibration_timeout

  input_proximity: !input input_proximity
  input_proximity_duration: !input input_proximity_duration
  input_proximity_distance: !input input_proximity_distance

  input_mode_outside_temperature: !input input_mode_outside_temperature
  input_mode_outside_temperature_threshold: !input input_mode_outside_temperature_threshold

  input_frost_protection_duration: !input input_frost_protection_duration

trigger:
  # S Y S T E M   T R I G G E R S
  - platform: homeassistant
    event: start
    id: hastart

  - platform: event
    event_type: automation_reloaded
    id: reload

  # S T A T E   T R I G G E R S
  - platform: state
    entity_id: !input input_trvs
    attribute: temperature
    for:
      seconds: 5
    id: temperature_change_valve_target

  # T E M P E R A T U R E   C H A N G E S
  - platform: template
    value_template: >
      {% if input_temperature_minimum != none %}
        {{ now() - states.input_number[input_temperature_minimum.split('.')[1]].last_updated >= timedelta(seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}
    id: temperature_change_minimum

  - platform: template
    value_template: >
      {% if input_temperature_comfort != none %}
        {{ now() - states.input_number[input_temperature_comfort.split('.')[1]].last_updated >= timedelta(seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}
    id: temperature_change_comfort

  # S C H E D U L E R   O N / O F F
  - platform: template
    id: scheduler_on
    value_template: >
      {% set trigger_state = 'on' %}
      {% set selected_scheduler = '' %}

      {% if input_schedulers | count == 0 %}
        {% set selected_scheduler = '' %}
      {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
        {% set selected_scheduler = input_schedulers[0] %}
      {% elif input_schedulers | count > 1 %}
        {% set selected_scheduler = input_schedulers[0] %}
        {% set selector_value = states(input_scheduler_selector) %}

        {% if is_number(selector_value) %}
          {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
          {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
          {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
        {% elif selector_value in ['on','off'] %}
          {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
        {% else %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
        {% endif %}

      {% endif %}

      {{ iif(selected_scheduler != '', is_state(selected_scheduler, trigger_state), false) }}

  - platform: template
    id: scheduler_off
    value_template: >
      {% set trigger_state = 'off' %}
      {% set selected_scheduler = '' %}

      {% if input_schedulers | count == 0 %}
        {% set selected_scheduler = '' %}
      {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
        {% set selected_scheduler = input_schedulers[0] %}
      {% elif input_schedulers | count > 1 %}
        {% set selected_scheduler = input_schedulers[0] %}
        {% set selector_value = states(input_scheduler_selector) %}

        {% if is_number(selector_value) %}
          {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
          {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
          {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
        {% elif selector_value in ['on','off'] %}
          {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
        {% else %}
          {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
        {% endif %}

      {% endif %}

      {{ iif(selected_scheduler != '', is_state(selected_scheduler, trigger_state), false) }}

  # P E R S O N  P R E S E N C E
  - platform: template
    value_template: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count > 0 }}"
    for: !input input_people_entering_home_duration
    id: person_on

  - platform: template
    value_template: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count == 0 }}"
    id: person_off
    for: !input input_people_leaving_home_duration

  # P R O X I M I T Y
  - platform: template
    id: person_proximity_on
    value_template: >
      {% set proximity_entities = device_entities(input_proximity) %}
      {% set is_arrived = proximity_entities  | expand 
                                                | selectattr('attributes.device_class', 'eq', 'enum') 
                                                | map(attribute='entity_id') | select('is_state','arrived') 
                                                | list | count > 0 %}

      {% set entities_towards = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'enum') 
                                              | map(attribute='entity_id') | select('is_state','towards') 
                                              | list %}

      {% set entities_distances = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'distance')
                                              | map(attribute='entity_id')
                                              | list %}

      {% set result = namespace(is_towards=false) %}
      {% for t in entities_towards %}
        {% set name = t.split('_')[:-1] | join('_') %}
        {% set entities_distances_filtered = entities_distances | expand | selectattr('entity_id','search',name) | map(attribute='entity_id') | list %}
        {% if result.is_towards == false and entities_distances_filtered | count > 0 %}
          {% set result.is_towards = states(entities_distances_filtered | first) | int <= input_proximity_distance | int %}
        {% endif %}
      {% endfor %}
      {% set is_towards = result.is_towards %}
      {{ is_towards or is_arrived }}
    for: !input input_proximity_duration

  - platform: template
    id: person_proximity_off
    value_template: >
      {% set proximity_entities = device_entities(input_proximity) %}
      {% set is_arrived = proximity_entities  | expand 
                                                | selectattr('attributes.device_class', 'eq', 'enum') 
                                                | map(attribute='entity_id') | select('is_state','arrived') 
                                                | list | count > 0 %}

      {% set entities_towards = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'enum') 
                                              | map(attribute='entity_id') | select('is_state','towards') 
                                              | list %}

      {% set entities_distances = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'distance')
                                              | map(attribute='entity_id')
                                              | list %}

      {% set result = namespace(is_towards=false) %}
      {% for t in entities_towards %}
        {% set name = t.split('_')[:-1] | join('_') %}
        {% set entities_distances_filtered = entities_distances | expand | selectattr('entity_id','search',name) | map(attribute='entity_id') | list %}
        {% if result.is_towards == false and entities_distances_filtered | count > 0 %}
          {% set result.is_towards = states(entities_distances_filtered | first) | int <= input_proximity_distance | int %}
        {% endif %}
      {% endfor %}
      {% set is_towards = result.is_towards %}
      {{ is_towards == false and is_arrived == false }}
    for: !input input_proximity_duration

  # W I N D O W  O P E N
  - platform: template
    value_template: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count > 0 }}"
    for: !input input_windows_reaction_time_open
    id: window_on

  - platform: template
    value_template: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count == 0 }}"
    for: !input input_windows_reaction_time_close
    id: window_off

  # M O D E   -   W I N T E R
  - platform: template
    id: winter_mode_on
    value_template: >
      {% if input_mode_winter != none %}
        {{ states(input_mode_winter) == 'on' }}
      {% endif %}
    for:
      seconds: 2

  - platform: template
    id: winter_mode_off
    value_template: >
      {% if input_mode_winter != none %}
        {{ states(input_mode_winter) == 'off' }}
      {% endif %}
    for:
      seconds: 2

  # O U T S I D E   T E M P E R A T U R E
  - platform: template
    id: outside_on
    value_template: >
      {% if input_mode_outside_temperature != none %}
        {% set state = states(input_mode_outside_temperature) %}
        {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}
        {{ state | int <= input_mode_outside_temperature_threshold | int }}
      {% endif %}
    for:
      seconds: 2

  - platform: template
    id: outside_off
    value_template: >
      {% if input_mode_outside_temperature != none %}
        {% set state = states(input_mode_outside_temperature) %}
        {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}
        {{ state | int > input_mode_outside_temperature_threshold | int }}
      {% endif %}
    for:
      seconds: 2

  # M O D E   -   M A I N T A N A C E
  - platform: template
    id: force_max_temperature_on
    value_template: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'on') }}"
    for:
      seconds: 2

  - platform: template
    id: force_max_temperature_off
    value_template: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'off') }}"
    for:
      seconds: 2

  # M O D E   -   P A R T Y
  - platform: template
    id: party_on
    value_template: "{{ input_mode_party != none and states(input_mode_party) in ['on','active'] }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_mode_party != none and states(input_mode_party) in ['off','idle','paused'] }}"
    id: party_off
    for:
      seconds: 2

  # M O D E   -   G U E S T
  - platform: template
    id: person_guest_on
    value_template: "{{ input_mode_guest != none and states(input_mode_guest) in ['on','active'] }}"
    for:
      seconds: 2

  - platform: template
    value_template: "{{ input_mode_guest != none and states(input_mode_guest) in ['off','idle','paused'] }}"
    id: person_guest_off
    for:
      seconds: 2

  # P R E S E N C E   S E N S O R
  - platform: template
    id: presence_on
    value_template: "{{ input_presence_sensor != none and is_state(input_presence_sensor, 'on') }}"
    for: !input input_presence_reaction_on_time

  - platform: template
    value_template: "{{ input_presence_sensor != none and is_state(input_presence_sensor, 'off') }}"
    id: presence_off
    for: !input input_presence_reaction_off_time

  # P R E S E N C E   S C H E D U L E R
  - platform: template
    id: presence_scheduler_on
    value_template: "{{ input_scheduler_presence != none and is_state(input_scheduler_presence, 'on') }}"
    for:
      seconds: 2

  - platform: template
    id: presence_scheduler_off
    value_template: "{{ input_scheduler_presence != none and is_state(input_scheduler_presence, 'off') }}"
    for:
      seconds: 2

  # E X T E R N A L  C A L I B R A T I O N   S E N S O R
  - platform: template
    id: calibration_sensor_temperature_change
    value_template: >
      {% if input_temperature_sensor != none %}
        {{ (now() - states.sensor[input_temperature_sensor.split('.')[1]].last_updated) >= timedelta(hours=input_calibration_timeout.hours, minutes=input_calibration_timeout.minutes, seconds=input_calibration_timeout.seconds) }}
      {% else %}
        {{ false }}
      {% endif %}

  - platform: state
    id: calibration_valve_temperature_change
    entity_id: !input input_trvs
    attribute: current_temperature
    for: !input input_calibration_timeout

  - platform: state
    id: valve_temperature_change_aggressive_mode
    entity_id: !input input_trvs
    attribute: current_temperature

  - platform: template
    id: calibration_popp_change
    value_template: >
      {% if input_temperature_sensor != none %}
        {{ (now() - states.sensor[input_temperature_sensor.split('.')[1]].last_updated) >= timedelta(hours=0, minutes=0, seconds=2) }}
      {% else %}
        {{ false }}
      {% endif %}

  - platform: template
    id: calibration_popp_ping
    value_template: >
      {% set has_valves_danfoss = input_trvs | select('is_device_attr', 'manufacturer', 'Danfoss') | list  %}
      {% set has_valves_popp = input_trvs | select('is_device_attr', 'manufacturer', 'Popp') | list %}
      {% set valves_hive = input_trvs | select('is_device_attr', 'manufacturer', 'Hive') | list %}

      {% set all_valves = has_valves_danfoss + has_valves_popp + valves_hive %}

      {% if all_valves | count == 0 or input_temperature_sensor == none %}
        {{ false }}
      {% else %}
        {{ now().strftime('%M') | int % 10 == 0 }}
      {% endif %}

  # C O M F O R T   T E M P   C H A N G E   B Y   T I M E
  - platform: template
    id: temperature_comfort_change_time_based
    value_template: "{{ now().strftime('%H:%M') in (input_time_based_temperature_change_valve_target | map(attribute='time') | list) }}"

  # F R O S T   P R O T E C T I O N
  - platform: template
    id: frost_protection_on
    value_template: >
      {% set is_frost_protection_configured = input_frost_protection_duration.hours | int > 0 or input_frost_protection_duration.minutes | int > 0 or input_frost_protection_duration.seconds | int > 0 %}
      {% set is_frost_protection_configured = iif(is_frost_protection_configured,is_frost_protection_configured,days in input_frost_protection_duration) %}
      {% set is_person_based = input_persons | count > 0 %}
      {% set is_presence_based = input_presence_sensor != none %}

      {% if is_frost_protection_configured == false or ( is_person_based == false and is_presence_based == false ) %}
        {{ false }}
      {% else %}
        {% set person_fp = false %}
        {% set presence_fp = false %}

        {% set delta = timedelta(**input_frost_protection_duration)%}

        {% if is_person_based %}
          {% set last_person_leaving = input_persons | expand | sort(attribute = 'last_changed', reverse=true) | map(attribute='entity_id') | first %}
          {% set person_fp = (now() - states.person[last_person_leaving.split('.')[1]].last_changed) >= delta %}
        {% endif %}

        {% if is_presence_based %}
          {% set presence_fp = (now() - ([input_presence_sensor] | expand | map(attribute='last_changed') | first)) >= delta %}
        {% endif %}

        {% if is_person_based and is_presence_based %}
          {{ person_fp and presence_fp }}
        {% else %}
          {{ iif(is_person_based, person_fp, presence_fp) }}
        {% endif %}
      {% endif %}

##################################################
############### V A R I A B L E S ################
##################################################

variables:
  # I N P U T S
  input_trvs: !input input_trvs
  input_temperature_comfort: !input input_temperature_comfort
  input_temperature_comfort_static: !input input_temperature_comfort_static
  input_temperature_minimum: !input input_temperature_minimum
  input_temperature_minimum_static: !input input_temperature_minimum_static

  #frost protection
  input_frost_protection_temp: !input input_frost_protection_temp
  input_frost_protection_duration: !input input_frost_protection_duration

  # heating scheduler
  input_schedulers: !input input_schedulers
  input_scheduler_selector: !input input_scheduler_selector

  input_scheduler_presence: !input input_scheduler_presence

  input_windows: !input input_windows

  input_mode_winter: !input input_mode_winter
  input_mode_outside_temperature: !input input_mode_outside_temperature
  input_mode_outside_temperature_threshold: !input input_mode_outside_temperature_threshold
  input_proximity: !input input_proximity

  input_mode_party: !input input_mode_party
  input_mode_guest: !input input_mode_guest
  input_force_max_temperature: !input input_force_max_temperature
  input_persons: !input input_persons
  input_presence_sensor: !input input_presence_sensor
  input_presence_reaction_off_time: !input input_presence_reaction_off_time
  input_presence_reaction_on_time: !input input_presence_reaction_on_time
  input_temperature_sensor: !input input_temperature_sensor
  input_calibration_delta: !input input_calibration_delta
  input_time_based_temperature_change_valve_target: !input input_time_based_temperature_change_valve_target
  input_service_call_delay: !input input_service_call_delay
  input_aggressive_mode_offset: !input input_aggressive_mode_offset
  input_aggressive_mode_range: !input input_aggressive_mode_range
  input_custom_action: !input input_custom_action
  input_tweaks: !input input_tweaks
  input_calibration_options: !input input_calibration_options
  input_tweaks_experimental: !input input_tweaks_experimental

  # TWEAKS
  is_reset_temperature: "{{ 'reset_temperature' in input_tweaks}}"
  is_off_instead_min: "{{ 'off_instead_min' in input_tweaks}}"
  is_not_off_but_min: "{{ 'not_off_but_min' in input_tweaks}}"
  is_auto_means_heat: "{{ 'auto_means_heat' in input_tweaks}}"
  is_fahrenheit: "{{ 'fahrenheit' in input_tweaks}}"

  is_generic_calibration: "{{ 'generic_calibration' in input_calibration_options}}"
  is_rounded_values: "{{ 'rounded_values' in input_calibration_options}}"

  is_physical_temperature_change: "{{ 'physical_temperature_change' in input_tweaks_experimental}}"
  is_physical_party_timer: "{{ 'physical_party_timer' in input_tweaks_experimental}}"

  # V A L V E   G R O U P S
  valves: "{{ expand(input_trvs) | map(attribute='entity_id') | list }}"
  valves_off_mode: "{{ valves | expand | selectattr('attributes.hvac_modes','search','(?i)off') | map(attribute='entity_id') | list }}"
  valves_without_off_mode: "{{ valves | reject('in',valves_off_mode) | list }}"

  # E V A L U A T I O N --------------------------------------------------------------

  # STATES
  state_mode_party: "{{ input_mode_party != none and states(input_mode_party) in ['on','active'] }}"
  state_mode_guest: "{{ input_mode_guest != none and states(input_mode_guest) in ['on','active'] }}"

  state_mode_winter: >
    {% if input_mode_winter != none %}
      {{ states(input_mode_winter) == 'on' }}
    {% else %}
      {{ true }}
    {% endif %}

  state_outside_temp: >
    {% if input_mode_outside_temperature != none %}
      {% set state = states(input_mode_outside_temperature) %}
      {% set state = iif(is_number(state) == true, state, state_attr(input_mode_outside_temperature,'temperature'))%}
      {{ state | int <= input_mode_outside_temperature_threshold | int }}
    {% else %}
      {{ true }}
    {% endif %}

  state_force_max_temperature: "{{ input_force_max_temperature != none and is_state(input_force_max_temperature, 'on') }}"
  state_window: "{{ expand(input_windows) | selectattr('state', 'eq', 'on') | list | count > 0 }}"

  active_scheduler: >
    {% set selected_scheduler = none %}

    {% if input_schedulers | count == 0 %}
      {% set selected_scheduler = none %}
    {% elif input_schedulers | count == 1 or input_scheduler_selector == none %}
      {% set selected_scheduler = input_schedulers[0] %}
    {% elif input_schedulers | count > 1 %}
      {% set selected_scheduler = input_schedulers[0] %}
      {% set selector_value = states(input_scheduler_selector) %}

      {% if is_number(selector_value) %}
        {% set selector_value = iif(selector_value | int > (input_schedulers | count), input_schedulers | count, selector_value) %}
        {% set selector_value = iif(selector_value | int <= 0, 1, selector_value) %}
        {% set selected_scheduler = input_schedulers[(selector_value | int) - 1] %}
      {% elif selector_value in ['on','off'] %}
        {% set selected_scheduler = iif(selector_value == 'off', input_schedulers[0], input_schedulers[1]) %}
      {% else %}
        {% set selected_scheduler = input_schedulers | expand | selectattr('attributes.friendly_name', 'search', '(?i)'+selector_value) | map(attribute='entity_id') | first %}
      {% endif %}
    {% endif %}

    {{ selected_scheduler }}

  # People Configuration
  is_person_based: "{{ input_mode_guest != none or input_persons | count > 0 }}"
  is_anybody_home: "{{ expand(input_persons) | selectattr('state', 'eq', 'home') | list | count > 0 or state_mode_guest }}"

  # Presence Configuration
  is_presence_sensor_defined: "{{ input_presence_sensor != none }}"
  is_presence_scheduler_defined: "{{ input_scheduler_presence != none }}"
  state_presence_sensor: "{{ is_presence_sensor_defined and is_state(input_presence_sensor, 'on') }}"
  state_presence_scheduler: "{{ is_presence_scheduler_defined and is_state(input_scheduler_presence, 'on') }}"

  is_presence_on: >
    {% set result = false %}
    {% if is_presence_sensor_defined %}
      {% set result = iif(is_presence_scheduler_defined, state_presence_scheduler and state_presence_sensor, state_presence_sensor) %}
    {% endif %}
    {{ iif(is_person_based, result and is_anybody_home, result) }}

  # Scheduler Configuration
  is_scheduled_heating: "{{ active_scheduler != none }}"
  state_scheduler: "{{ is_scheduled_heating and is_state(active_scheduler,'on') }}"

  is_scheduled_heating_on: >
    {{ iif(is_person_based, state_scheduler and is_anybody_home, state_scheduler) }}

  # Proximity
  is_somebody_on_way_home_state: >
      {% set proximity_entities = device_entities(input_proximity) %}

      {% set is_arrived = proximity_entities  | expand 
                                                | selectattr('attributes.device_class', 'eq', 'enum') 
                                                | map(attribute='entity_id') | select('is_state','arrived') 
                                                | list | count > 0 %}

      {% set entities_towards = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'enum') 
                                              | map(attribute='entity_id') | select('is_state','towards') 
                                              | list %}

      {% set entities_distances = proximity_entities  | expand 
                                              | selectattr('attributes.device_class', 'eq', 'distance')
                                              | map(attribute='entity_id')
                                              | list %}

      {% set result = namespace(is_towards=false) %}
      {% for t in entities_towards %}
        {% set name = t.split('_')[:-1] | join('_') %}
        {% set entities_distances_filtered = entities_distances | expand | selectattr('entity_id','search',name) | map(attribute='entity_id') | list %}
        {% if result.is_towards == false and entities_distances_filtered | count > 0 %}
          {% set result.is_towards = states(entities_distances_filtered | first) | int <= input_proximity_distance | int %}
        {% endif %}
      {% endfor %}
      {% set is_towards = result.is_towards %}

      {{ (is_scheduled_heating == false and is_presence_sensor_defined == false and is_arrived == true) or is_towards == true}}

  is_somebody_on_way_home: >
    {% if is_somebody_on_way_home_state == false %}
      {{ false }}
    {% elif state_scheduler %}
      {{ true }}
    {% elif is_presence_sensor_defined and is_presence_scheduler_defined == false %}
      {{ true }}
    {% elif is_presence_sensor_defined and is_presence_scheduler_defined %}
      {{ state_presence_scheduler }}
    {% elif is_presence_sensor_defined == false and is_person_based and is_scheduled_heating == false %}
      {{ true }}
    {% else %}
      {{ is_somebody_on_way_home_state }}
    {% endif %}

  is_frost_protection: >
    {% set is_frost_protection_configured = input_frost_protection_duration.hours | int > 0 or input_frost_protection_duration.minutes | int > 0 or input_frost_protection_duration.seconds | int > 0 %}
    {% set is_frost_protection_configured = iif(is_frost_protection_configured,is_frost_protection_configured,days in input_frost_protection_duration) %}
    {% set is_person_based = input_persons | count > 0 %}
    {% set is_presence_based = input_presence_sensor != none %}

    {% if is_frost_protection_configured == false or ( is_person_based == false and is_presence_based == false ) %}
      {{ false }}
    {% else %}
      {% set person_fp = false %}
      {% set presence_fp = false %}

      {% set delta = timedelta(**input_frost_protection_duration)%}

      {% if is_person_based %}
        {% set last_person_leaving = input_persons | expand | sort(attribute = 'last_changed', reverse=true) | map(attribute='entity_id') | first %}
        {% set person_fp = (now() - states.person[last_person_leaving.split('.')[1]].last_changed) >= delta %}
      {% endif %}

      {% if is_presence_based %}
        {% set presence_fp = (now() - ([input_presence_sensor] | expand | map(attribute='last_changed') | first)) >= delta %}
      {% endif %}

      {% if is_person_based and is_presence_based %}
        {{ person_fp and presence_fp }}
      {% else %}
        {{ iif(is_person_based, person_fp, presence_fp) }}
      {% endif %}
    {% endif %}

  # T R V - V A L U E S
  set_comfort: >
    {% if state_mode_party == true or is_somebody_on_way_home %}
      {{ true }}
    {% elif is_person_based and is_presence_sensor_defined == false and is_scheduled_heating == false %}
      {{ is_anybody_home }}
    {% else %}
      {{ is_scheduled_heating_on or is_presence_on }}
    {% endif %}

  mode: >
    {% set heating_mode = 'off' %}

    {% if state_force_max_temperature == true %}
      {% set heating_mode = 'heat' %}
    {% elif state_mode_winter == false or state_outside_temp == false or state_window == true %}
      {% set heating_mode = 'off' %}
    {% elif set_comfort == false %}
      {% set heating_mode = iif(is_off_instead_min == true, 'off', 'heat') %}
    {% elif set_comfort == true %}
      {% set heating_mode = 'heat' %}
    {% endif %}

    {{ iif(is_auto_means_heat and heating_mode == 'heat', 'auto', heating_mode) }}

  is_physical_change: >
    {{
      trigger.id == 'temperature_change_valve_target' and
      trigger.to_state.context.id != none and
      trigger.to_state.context.parent_id == none and
      trigger.to_state.context.user_id == none and
      is_physical_temperature_change == true
    }}

  is_automation_change: >
    {{
      trigger.id == 'temperature_change_valve_target' and
      trigger.to_state.context.id != none and
      trigger.to_state.context.parent_id != none and
      trigger.to_state.context.user_id == none
    }}

  is_ui_change: >
    {{
      trigger.id == 'temperature_change_valve_target' and
      trigger.to_state.context.id != none and
      trigger.to_state.context.parent_id == none and
      trigger.to_state.context.user_id != none
    }}

  is_manual_timer_start: >
    {{
      trigger.id == 'temperature_change_valve_target' and
      trigger.to_state.context.id != none and
      trigger.to_state.context.parent_id == none and
      trigger.to_state.context.user_id == none and
      is_physical_party_timer == true and
      input_mode_party != none and
      input_mode_party.split('.')[0] == 'timer' and
      state_mode_party == false
    }}

  is_temperature_change: >
    {{
      is_ui_change or is_physical_change
    }}

  temperature_change_temperature: >
    {% if is_ui_change or is_physical_change %}
      {{ trigger.to_state.attributes.temperature }}
    {% else %}
      {{ none }}
    {% endif %}

  is_reset: >
    {{
      input_temperature_comfort != none and
      float(states(input_temperature_comfort)) != float(input_temperature_comfort_static) and
      (
        trigger.id in ['party_off'] or
        (trigger.id in ['scheduler_off','person_off','person_guest_off','sensor-presence-off'] and
        set_comfort == false)
      ) and
      is_reset_temperature == true
    }}

  # EVLAUATING TRIGGER IDs
  is_calibration: >
    {{
      mode != 'off' and
      trigger.id in ['calibration_sensor_temperature_change','calibration_valve_temperature_change'] and
      input_temperature_sensor != none
    }}

  # ------------------------------------------------------------------------------------
  # ----------------------------- TIME BASED MODIFIERS ---------------------------------
  # ------------------------------------------------------------------------------------

  entry: >
    {% set plan = input_time_based_temperature_change_valve_target | rejectattr('time', 'undefined') | list %}
    {% set day = now().strftime('%a') %}
    {% set current_time = now().strftime('%H%M') | int %}
    {% set result = namespace(entry=none) %}

    {% for e in plan %}
      {% if 'days' in e.keys() and day not in e['days'] %}
        {% set e = none %}
      {% endif %}

      {% if e != none and 'scheduler' in e.keys() and active_scheduler != e['scheduler'] %}
        {% set e = none %}
      {% endif %}

      {% if e != none%}
        {% set e_time = e['time'].replace(':','') | int %}
        
        {% if e_time <= current_time and
              (result.entry == none or 
                e_time >= result.entry['time'].replace(':','') | int) %}
          {% set result.entry = e %}
        {% endif %}
      {% endif %}
    {% endfor %}

    {{ result.entry }}

  entry_time: >
    {% if (entry is defined) and entry  %}
      {% set entry_hour = entry['time'].split(':')[0] | int %}
      {% set entry_minute = entry['time'].split(':')[1] | int %}
      {{ now().replace(hour=entry_hour, minute=entry_minute, second=0, microsecond=0) }}
    {% endif %}

  entry_comfort_temp: >
    {% if (entry is defined) and entry and 'comfort' in entry.keys() %}
      {{ entry['comfort'] }}
    {% else %}
      {{ none }}
    {% endif %}

  entry_eco_temp: >
    {% if (entry is defined) and entry and 'eco' in entry.keys() %}
      {{ entry['eco'] }}
    {% else %}
      {{ none }}
    {% endif %}

  entry_calibration: >
    {% if (entry is defined) and entry and 'calibration' in entry.keys() %}
      {{ entry['calibration'] == 'on' }}
    {% else %}
      {{ true }}
    {% endif %}

  new_comfort_temperature: >
    {% if trigger.id == 'hastart' and entry_comfort_temp != none %}
      {{ entry_comfort_temp }}
    {% elif entry_comfort_temp != none and input_temperature_comfort == none %}
      {{ entry_comfort_temp }}
    {% elif entry_comfort_temp != none and 
            input_temperature_comfort != none and 
            as_timestamp(states.input_number[input_temperature_comfort.split('.')[1]].last_changed) < as_timestamp(entry_time,0) %}
      {{ entry_comfort_temp }}
    {% else %}
      {{ none }}
    {% endif %}

  new_eco_temperature: >
    {% if trigger.id == 'hastart' and entry_eco_temp != none %}
      {{ entry_eco_temp }}
    {% elif entry_eco_temp != none and input_temperature_minimum == none %}
      {{ entry_eco_temp }}
    {% elif entry_comfort_temp != none and 
            input_temperature_minimum != none and 
            as_timestamp(states.input_number[input_temperature_minimum.split('.')[1]].last_changed) < as_timestamp(entry_time,0) %}
      {{ entry_eco_temp }}
    {% else %}
      {{ none }}
    {% endif %}

  # ------------------------------------------------------------------------------------
  # ----------------------------- CHANGES & CALIBRATION --------------------------------
  # ------------------------------------------------------------------------------------

  is_refresh_comfort_entity: >
    {{ input_temperature_comfort != none and 
        new_comfort_temperature != none and
        new_comfort_temperature | float != states(input_temperature_comfort) | float }}

  is_refresh_eco_entity: >
    {{ input_temperature_minimum != none and 
        new_eco_temperature != none and
        new_eco_temperature | float != states(input_temperature_minimum) | float }}

  state_temperature_comfort: >
    {% if input_temperature_comfort != none %}
      {{ states(input_temperature_comfort) }}
    {% elif new_comfort_temperature != none and new_comfort_temperature != '' %}
        {{ new_comfort_temperature }}
    {% else %}
      {{ input_temperature_comfort_static }}
    {% endif %}

  state_temperature_min: >
    {% if is_frost_protection %}
      {{ input_frost_protection_temp }}
    {% else %}
      {% if input_temperature_minimum != none %}
        {{ states(input_temperature_minimum) }}
      {% elif new_eco_temperature != none and new_eco_temperature != '' %}
        {{ new_eco_temperature }}
      {% else %}
        {{ input_temperature_minimum_static }}
      {% endif %}
    {% endif %}

  temperature: >
    {% if is_temperature_change %}
      {{ temperature_change_temperature }}
    {% else %}
      {{ iif(set_comfort, state_temperature_comfort, state_temperature_min) }}
    {% endif %}

  changes: >
    {% set n = namespace(dict=[]) %}
    {% for valve in input_trvs %}

      {% set current_valve_temp = state_attr(valve, 'current_temperature') | float(20) %}
      {% set current_valve_target_temp = state_attr(valve, 'temperature') | float(temperature) %}
      {% set current_valve_mode = states(valve) %}
      {% set min_temp = state_attr(valve, 'min_temp') | float(5) %}
      {% set max_temp = state_attr(valve, 'max_temp') | float(30) %}

      {% set valve_mode = iif(mode == 'off' and (valve in valves_without_off_mode or is_not_off_but_min), 'heat', mode) %}
      {% set valve_temp = temperature %}
      {% set valve_temp = iif(is_not_off_but_min and mode == 'off', min_temp, temperature) %}
      {% set valve_temp = iif(state_force_max_temperature and mode != 'off', max_temp, temperature) %}

      {% if valve_mode != 'off' %}

        {% if input_aggressive_mode_range > 0 and input_aggressive_mode_offset > 0 %}
          {% set temp_diff = valve_temp - current_valve_temp %}

          {% if temp_diff < input_aggressive_mode_range * -1 %}
            {% set valve_temp = valve_temp - input_aggressive_mode_offset %}
          {% elif temp_diff > input_aggressive_mode_range %}
            {% set valve_temp = valve_temp + input_aggressive_mode_offset %}
          {% endif %}

          {% if valve_temp < min_temp %}
            {% set valve_temp = min_temp %}
          {% elif valve_temp > max_temp %}
            {% set valve_temp = max_temp %}
          {% endif %}

        {% endif %}

        {% if is_generic_calibration and input_temperature_sensor != none %}

          {% set sensor_temp = states(input_temperature_sensor) %}

          {% if current_valve_temp != sensor_temp %}
            {% set offset = sensor_temp | float(0) - current_valve_temp | float(0) %}
            {% set temp_with_offset = float(valve_temp) - float(offset) %}
            {% set step = state_attr(valve, 'target_temp_step') | float(0.5) %}

            {% set temp_with_offset = (temp_with_offset | float(0) / float(step)) | round(0) * float(step) %}

            {% if(temp_with_offset > max_temp) %}
              {% set temp_with_offset = max_temp %}
            {% elif (temp_with_offset < min_temp) %}
              {% set temp_with_offset = min_temp %}
            {% endif %}

            {% set valve_temp = iif(is_rounded_values == true, float(temp_with_offset) | round(), temp_with_offset | round(1)) %}

          {% endif %}
        {% endif %}

      {% endif %}

      {% if state_window == true %}

        {% set valve_temp = iif(mode == 'off' and valve in valves_without_off_mode, min_temp, valve_temp) %}
        {% set valve_mode = iif(mode == 'off' and valve in valves_without_off_mode, 'heat', 'off') %}
      
      {% endif %}

      {% if current_valve_mode != valve_mode or 
          current_valve_target_temp != valve_temp%}
        {% set n.dict = n.dict + [(valve, [{'mode': valve_mode , 'temp': valve_temp}])] %}
      {% endif %}

    {% endfor %}

    {{ dict.from_keys(n.dict) }}

  # --------------------------------------------
  # CALIBRATION --------------------------------
  # --------------------------------------------

  VAR_UNIT_OF_MEASUREMENT: "unit_of_measurement"

  is_metric: "{{ input_temperature_sensor == none or (input_temperature_sensor != none and state_attr(input_temperature_sensor,VAR_UNIT_OF_MEASUREMENT) == 'Â°C') }}"

  rounding: "{{ iif(is_rounded_values, 0, 2)  | float }}"

  # TADO
  valves_tado: "{{ valves | select('is_device_attr', 'manufacturer', 'Tado') | list }}"
  calibration_tado: >
    {% set n = namespace(dict=[]) %}

    {% if is_calibration and is_generic_calibration == false and entry_calibration %}
      {% for valve in valves_tado %}

        {% set offset_old = state_attr(valve, iif(is_metric, 'offset_celsius', 'offset_fahrenheit')) | float %}
        {% set local_temperature = state_attr(valve, 'current_temperature') | float %}
        {% set calibration_sensor_temperature = states(input_temperature_sensor) %}

        {% set offset = float(calibration_sensor_temperature) - float(local_temperature) %}
        {% set offset_new = ( float(offset) + (offset_old | float(0)) ) | round(rounding) %}

        {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) %}
          {% set n.dict = n.dict + [(valve, [{'value': offset_new}])] %}
        {% endif %}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  # XIAOMI / AQARA
  valves_xiaomi_xiaomi: "{{ valves | select('is_device_attr', 'manufacturer', 'Xiaomi') | list }}"
  valves_xiaomi_aqara: "{{ valves | select('is_device_attr', 'manufacturer', 'Aqara') | list }}"
  valves_xiaomi: "{{ valves_xiaomi_xiaomi + valves_xiaomi_aqara }}"
  calibration_xiaomi: >
    {% set n = namespace(dict=[]) %}

    {% if is_calibration and is_generic_calibration == false and entry_calibration %}
      {% for valve in valves_xiaomi %}

        {% set calibration_entities = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    map(attribute='entity_id') | list %}

        {% if calibration_entities | count > 0 %}

          {% set calibration_entity = calibration_entities | first %}
          {% set offset_old = states(calibration_entity) | float(0) %}
          {% set offset_new = states(input_temperature_sensor) | float %}

          {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) %}
            {% set n.dict = n.dict + [(calibration_entity, [{'value': offset_new, 'valve': valve}])] %}
          {% endif %}
        {% endif %}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  # DANFOSS, POPP, HIVE
  valves_danfoss: "{{ valves | select('is_device_attr', 'manufacturer', 'Danfoss') | list }}"
  valves_popp: "{{ valves | select('is_device_attr', 'manufacturer', 'Popp') | list }}"
  valves_hive: "{{ valves | select('is_device_attr', 'manufacturer', 'Hive') | list }}"
  valves_external_sensor: "{{ valves_danfoss + valves_popp + valves_hive }}"

  is_periodical_popp_calibration: >
    {{ trigger.id in ['calibration_popp_ping','hastart','reload'] }}

  is_difference_popp_calibration: >
    {{ trigger.id in ['calibration_popp_change'] }}

  calibration_external_sensor: >
    {% set n = namespace(dict=[]) %}
    {% if (is_periodical_popp_calibration or is_difference_popp_calibration) and is_generic_calibration == false and entry_calibration %}
      
      {% for valve in valves_external_sensor %}

        {% set calibration_entity = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    selectattr('entity_id', 'search', 'external') |
                                    map(attribute='entity_id') | first %}

        {% set calibration_sensor_temperature = states(input_temperature_sensor) | float %}
        {% set new_state = (calibration_sensor_temperature | float(0) * 100) | int %}
        {% set old_state = states(calibration_entity) | int %}

        {% set update_calibration = false %}

        {% if is_periodical_popp_calibration %}
          {% set last_updated = [calibration_entity] | expand | map(attribute='last_updated') | first %}
          {% set update_calibration = now() - timedelta(minutes=20) >= last_updated %}
        {% endif %}

        {% if is_difference_popp_calibration %}
          {% set update_calibration = old_state != new_state %}
        {% endif %}
        
        {% if update_calibration %}
          {% set n.dict = n.dict + [(calibration_entity, [{'value': new_state, 'valve': valve}])] %}
        {% endif%}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  # COMMON CALIBRATION e.g. TUYA
  valves_calibration_common: "{{ valves | reject('in', valves_tado + valves_external_sensor + valves_xiaomi) | list }}"
  calibration_common: >
    {% set n = namespace(dict=[]) %}

    {% if is_calibration and is_generic_calibration == false and entry_calibration %}
      
      {% for valve in valves_calibration_common %}

        {% set calibration_entities = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    selectattr('entity_id', 'search', 'offset') |
                                    map(attribute='entity_id') | list %}

        {% if calibration_entities | count == 0 %}
          {% set calibration_entities = device_entities(device_id(valve)) |
                                    expand | selectattr('domain','in','number') |
                                    selectattr('entity_id', 'search', 'calibration') |
                                    map(attribute='entity_id') | list %}
        {% endif %}

        {% if calibration_entities | count > 0 %}

          {% set calibration_entity = calibration_entities | first %}
          {% set step = state_attr(calibration_entity, 'step') | float %}
          {% set min_calibration_value = state_attr(calibration_entity,'min') | float %}
          {% set max_calibration_value = state_attr(calibration_entity,'max') | float %}
          {% set thermostat_temperature = state_attr(valve, 'current_temperature') | float %}
          {% set calibration_sensor_temperature = states(input_temperature_sensor) | float %}
          {% set offset_old = states(calibration_entity) | float(0) %}

          {% set new_calibration_value = calibration_sensor_temperature - (thermostat_temperature - offset_old) %}

          {% set new_calibration_value = iif(new_calibration_value > max_calibration_value, max_calibration_value, new_calibration_value) %}
          {% set new_calibration_value = iif(new_calibration_value < min_calibration_value, min_calibration_value, new_calibration_value) %}
          
          {% set round_size = iif('.' in (step | string) and is_rounded_values == false, (step | string).split('.')[1] | length, 0) %}

          {% set offset_new = ((new_calibration_value | float(0) / step) | round(0) * step) | round(round_size) | float %}
          

          {% if (float(offset_old) - float(offset_new)) | abs >= float(input_calibration_delta) %}
            {% set n.dict = n.dict + [(calibration_entity, [{'value': offset_new, 'valve': valve}])] %}
          {% endif %}

        {% endif %}

      {% endfor %}
    {% endif %}

    {{ dict.from_keys(n.dict) }}

  calibration_number: "{{ dict(dict(calibration_xiaomi, **calibration_external_sensor),**calibration_common) }}"

  is_heating: "{{ set_comfort and mode != 'off' }}"

##################################################
########### C O N D I T I O N S ##################
##################################################

condition:
  - condition: or
    conditions:
      - condition: template
        value_template: "{{ calibration_number | count > 0 }}"
      - condition: template
        value_template: "{{ calibration_tado | count > 0 }}"
      - condition: template
        value_template: "{{ changes | count > 0 }}"
      - condition: template
        value_template: "{{ is_manual_timer_start }}"
      - condition: template
        value_template: "{{ is_reset }}"
      - condition: template
        value_template: "{{ is_refresh_comfort_entity or is_refresh_eco_entity or is_temperature_change }}"

##################################################
################## A C T I O N ###################
##################################################

action:
  - if:
      - condition: template
        value_template: "{{ trigger.id in ['hastart','reload'] }}"
    then:
      - delay:
          seconds: 10

  - service: system_log.write
    data:
      message: >
        AHC REF  {{" \n "}}
        {{" \n "}}
        TRIGGER {{" \n "}}
        is_calibration: {{ calibration_number | count > 0 or calibration_tado | count > 0 }} {{" \n "}}
        is_changes: {{ changes | count > 0 }} {{" \n "}}
        is_manual: {{ is_physical_change or is_manual_timer_start }} {{" \n "}}
        is_reset: {{ is_reset }} {{" \n "}}
        is_refresh_comfort_entity: {{ is_refresh_comfort_entity or is_refresh_eco_entity }} {{" \n "}}
        {{" \n "}}
        proximity: {{ input_proximity }} {{ " \n " }}
        is_somebody_on_way_home_state: {{ is_somebody_on_way_home_state }} {{ " \n " }}
        proximity_entities: {{ device_entities(input_proximity) }} {{ " \n " }}
        entry: {{ entry }} {{ " \n " }}
        entry_time: {{ entry_time }} {{ " \n " }}
        entry_comfort_temp: {{ entry_comfort_temp }} {{ " \n " }}
        new_comfort_temperature: {{ new_comfort_temperature }} {{ " \n " }}
        is_refresh_comfort_entity: {{ is_refresh_comfort_entity }} {{ " \n " }}
        state_mode_winter: {{ state_mode_winter }} {{ " \n " }}
        state_mode_party: {{ state_mode_party }} {{ " \n " }}
        state_mode_guest: {{ state_mode_guest }} {{ " \n " }}
        state_outside_temp: {{ state_outside_temp }} {{ " \n " }}
        state_force_max_temperature: {{ state_force_max_temperature }} {{ " \n " }}
        state_window: {{ state_window }} {{ " \n " }}
        state_temperature_comfort: {{ state_temperature_comfort }} {{ " \n " }}
        active_scheduler: {{ active_scheduler }} {{ " \n " }}
        is_person_based: {{ is_person_based }} {{ " \n " }}
        is_anybody_home: {{ is_anybody_home }} {{ " \n " }}
        is_somebody_on_way_home_state: {{ is_somebody_on_way_home_state }} {{ " \n " }}
        is_presence_sensor_defined: {{ is_presence_sensor_defined }} {{ " \n " }}
        is_presence_scheduler_defined: {{ is_presence_scheduler_defined }} {{ " \n " }}
        state_presence_sensor: {{ state_presence_sensor }} {{ " \n " }}
        state_presence_scheduler: {{ state_presence_scheduler }} {{ " \n " }}
        is_presence_on: {{ is_presence_on }} {{ " \n " }}
        is_scheduled_heating: {{ is_scheduled_heating }} {{ " \n " }}
        state_scheduler: {{ state_scheduler }} {{ " \n " }}
        is_scheduled_heating_on: {{ is_scheduled_heating_on }} {{ " \n " }}
        is_somebody_on_way_home: {{ is_somebody_on_way_home }} {{ " \n " }}
        is_frost_protection: {{ is_frost_protection }} {{ " \n " }}
        state_temperature_min: {{ state_temperature_min }} {{ " \n " }}
        set_comfort: {{ set_comfort }} {{ " \n " }}
        mode: {{ mode }} {{ " \n " }}
        temperature: {{ temperature }} {{ " \n " }}
        is_physical_change: {{ is_physical_change }} {{ " \n " }}
        is_manual_timer_start: {{ is_manual_timer_start }} {{ " \n " }}
        is_calibration: {{ is_calibration }} {{ " \n " }}
        changes: {{ changes }} {{ " \n " }}
        valves_tado: {{ valves_tado }} {{ " \n " }}
        calibration_tado: {{ calibration_tado }} {{ " \n " }}
        valves_xiaomi: {{ valves_xiaomi }} {{ " \n " }}
        calibration_xiaomi: {{ calibration_xiaomi }} {{ " \n " }}
        valves_external_sensor: {{ valves_external_sensor }} {{ " \n " }}
        calibration_external_sensor: {{ calibration_external_sensor }} {{ " \n " }}
        valves_calibration_common: {{ valves_calibration_common }} {{ " \n " }}
        calibration_common: {{ calibration_common }} {{ " \n " }}
        is_heating: {{ is_heating }} {{ " \n " }}
        is_metric: {{ is_heating }} {{ " \n " }}
      level: !input input_log_level
      logger: blueprints.panhans.heatingcontrol

  - choose:
      # TIMER STOP RESET
      - conditions:
          - condition: template
            value_template: "{{ is_reset }}"
        sequence:
          - service: input_number.set_value
            data:
              value: "{{ input_temperature_comfort_static }}"
            target:
              entity_id: !input input_temperature_comfort

    default:
      # UPDATE TEMPERATURE ENTITIES
      - if: # COMFORT ENTITY
          - condition: template
            value_template: "{{ input_temperature_comfort != none and 
                                ((is_temperature_change and set_comfort) or is_refresh_comfort_entity) }}"
        then:
          - variables:
              max_comfort_temp: "{{ state_attr(input_temperature_comfort,'max') | float }}"
              min_comfort_temp: "{{ state_attr(input_temperature_comfort,'min') | float }}"

              new_manual_temp: >
                {% if is_refresh_comfort_entity %}
                  {{ new_comfort_temperature }}
                {% else %}
                  {{ temperature_change_temperature }}
                {% endif %}
              real_manual_temp: >
                {% if (new_manual_temp > max_comfort_temp) %}
                  {{ max_comfort_temp }}
                {% elif (new_manual_temp < min_comfort_temp ) %}
                  {{ min_comfort_temp }}
                {% else %}
                  {{ new_manual_temp }}
                {% endif %}

          - condition: template
            value_template: "{{  real_manual_temp != state_temperature_comfort }}"

          - service: input_number.set_value
            data:
              value: "{{ real_manual_temp }}"
            target:
              entity_id: !input input_temperature_comfort

      - if: #ECO ENTITY
          - condition: template
            value_template: "{{ input_temperature_minimum != none and
                                ((is_temperature_change and set_comfort == false) or is_refresh_eco_entity) }}"
        then:
          - variables:
              max_eco_temp: "{{ state_attr(input_temperature_minimum,'max') | float }}"
              min_eco_temp: "{{ state_attr(input_temperature_minimum,'min') | float }}"
              
              new_manual_temp: >
                {% if is_refresh_eco_entity %}
                  {{ new_eco_temperature }}
                {% else %}
                  {{ temperature_change_temperature }}
                {% endif %}
              real_manual_temp: >
                {% if (new_manual_temp > max_eco_temp) %}
                  {{ max_eco_temp }}
                {% elif (new_manual_temp < min_eco_temp ) %}
                  {{ min_eco_temp }}
                {% else %}
                  {{ new_manual_temp }}
                {% endif %}

          - condition: template
            value_template: "{{  real_manual_temp != state_temperature_comfort }}"

          - service: input_number.set_value
            data:
              value: "{{ real_manual_temp }}"
            target:
              entity_id: !input input_temperature_minimum

      - if: # MANUAL TIMER START
          - condition: template
            value_template: "{{ is_manual_timer_start }}"
        then:
          - service: timer.start
            target:
              entity_id: "{{ input_mode_party }}"
          - delay:
              hours: "{{ input_service_call_delay.hours }}"
              minutes: "{{ input_service_call_delay.minutes }}"
              seconds: "{{ input_service_call_delay.seconds }}"

      # NUMBER CALIBRATION
      - repeat:
          count: "{{ calibration_number | count | int }}"
          sequence:
            - variables:
                index: "{{ repeat.index-1 }}"
                calibration_entity: "{{ (calibration_number.keys() | list) [index] }}"
                thermostat: "{{ (((calibration_number.values() | list) [index]) | first) ['valve'] }}"
                offset: "{{ (((calibration_number.values() | list) [index]) | first) ['value'] }}"

            - service: system_log.write
              data:
                message: >
                  AHC REF CALIBRATION  {{" \n "}}
                  calibration entity: {{ calibration_entity }}  {{" \n "}}
                  offset: {{ offset }}
                level: !input input_log_level
                logger: blueprints.panhans.heatingcontrol

            - service: number.set_value
              data:
                value: "{{ float(offset) }}"
              target:
                entity_id: "{{ calibration_entity }}"
            - delay:
                hours: "{{ input_service_call_delay.hours }}"
                minutes: "{{ input_service_call_delay.minutes }}"
                seconds: "{{ input_service_call_delay.seconds }}"

      # TADO CALIBRATION
      - repeat:
          count: "{{ calibration_tado | count | int }}"
          sequence:
            - variables:
                index: "{{ repeat.index-1 }}"
                thermostat: "{{ (calibration_tado.keys() | list) [index] }}"
                offset: "{{ (((calibration_tado.values() | list) [index]) | first) ['value'] }}"
            - service: tado.set_climate_temperature_offset
              data:
                offset: "{{ offset }}"
                entity_id: "{{ thermostat }}"
            - delay:
                hours: "{{ input_service_call_delay.hours }}"
                minutes: "{{ input_service_call_delay.minutes }}"
                seconds: "{{ input_service_call_delay.seconds }}"

      # SET TEMPERATURE
      - service: system_log.write
        data:
          message: >
            AHC REF  {{" \n "}}
            change_count: {{ changes | count | int }}  {{" \n "}}
            changes: {{ changes }}
          level: !input input_log_level
          logger: blueprints.panhans.heatingcontrol
      - repeat:
          count: "{{ changes | count | int }}"
          sequence:
            - variables:
                index: "{{ repeat.index-1 }}"
                thermostat: "{{ (changes.keys() | list) [index] }}"
                mode: "{{ (((changes.values() | list) [index]) | first) ['mode'] }}"
                target_temperature: "{{ (((changes.values() | list) [index]) | first) ['temp'] }}"
            - service: system_log.write
              data:
                message: >
                  thermostat: {{ thermostat }}
                  mode: {{ mode }}
                  new_target: {{ target_temperature }}
                  current_target: {{ state_attr(thermostat,'temperature') }}
                level: !input input_log_level
                logger: blueprints.panhans.heatingcontrol

            - service: system_log.write
              data:
                message: >
                  AHC REF CHANGES: {{ thermostat }} -> {{ mode }} -> {{ target_temperature }}
                level: !input input_log_level
                logger: blueprints.panhans.heatingcontrol

            - if:
                - condition: template
                  value_template: "{{ states(thermostat) | lower != mode | lower  }}"
              then:
                - service: climate.set_hvac_mode
                  data:
                    entity_id: "{{ thermostat }}"
                    hvac_mode: "{{ mode }}"

                - delay:
                    hours: "{{ input_service_call_delay.hours }}"
                    minutes: "{{ input_service_call_delay.minutes }}"
                    seconds: "{{ input_service_call_delay.seconds }}"

            - if:
                - condition: template
                  value_template: "{{ state_attr(thermostat, 'temperature') != target_temperature and mode != 'off' }}"
              then:
                - service: climate.set_temperature
                  data:
                    entity_id: "{{ thermostat }}"
                    temperature: "{{ target_temperature | float }}"

                - delay:
                    hours: "{{ input_service_call_delay.hours }}"
                    minutes: "{{ input_service_call_delay.minutes }}"
                    seconds: "{{ input_service_call_delay.seconds }}"

      - if:
          - condition: template
            value_template: "{{ input_custom_action != none }}"
        then: !input "input_custom_action"

mode: queued
